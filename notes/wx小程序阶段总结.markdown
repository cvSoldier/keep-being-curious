之后小程序应该会做得比较少了，总结一下，免得狗熊掰棒子。
## 小程序的双层架构 ##
小程序不同于浏览器，运行环境分成渲染层和逻辑层，其中 WXML 模板和 WXSS 样式工作在渲染层，JS 脚本工作在逻辑层。通过setData()通信。  
为啥要搞这种：对比h5，单线程，js的运行逻辑过于复杂的话会影响页面交互的流畅程度。小程序采用双层的话，js再复杂，也不会影响渲染层。缺点就是需要通信。  
比如h5处理滚动这种类型的事件，使用节流或者防抖，他们没有减少事件的触发次数，只是减少了目标函数的执行次数。  
但是在小程序中，即使使用了节流防抖，也没有减少事件的触发次数，就会导致频繁的双层的通信带来性能损耗。  
也因此在微信官方在2.4.4支持使用wxs相应事件，wxs就是运行在渲染层的逻辑。举个例子：  

### wxs响应事件 ###
有个需求是一个列表页，支持左滑出现删除按钮，点击删除，滑动的方式是不断修改元素的translateX。当时项目使用的组件库包含滑动组件，但是组件库兼容的版本更低，所以使用的依然是   
```
渲染层触发 - 通信 - 逻辑层setData修改偏移量 - 通信  
``` 
的方式，当时项目定的最低版本是2.6.几，是完全可以用wxs来做滑动的，微信官方的文档也有样例工程，这里就不再赘述了，至少我是明显能感觉到使用wxs会更加丝滑，因为小程序的开发工具好像没有performace之类工具，当时也没有量化差异。不过最后还是使用了组件库的逻辑层处理事件的方式，倒不是因为wxs需要自己开发，而是另外一个有意思的特性。  
组件库的滑动组件实现了全局只有唯一组件实例处在滑动状态，类似这样(用vue的代码代替，思路是相同的)
```javascript
const instances = {}
let curId
let id = 0

export default {
  data() {
    return {
      id: id++
    }
  },
  created() {
    instances[this.id] = this
  },
  beforeDestroy() {
    instances[this.id] = undefined
  }
  methods: {
    handleSlide(e) {
      // 如果当前的滑动实例，不是现在的实例，把当前的划回来。
      curId !== this.id && instances[curId].slide(0)
      curId = this.id
      this.slide(e)
    },
    slide(e) {
      // ...
    }
  }
}
```
但是用wxs获取组件的this很麻烦，就导致实现相同的功能很麻烦。

## 登录流程 ##
在pc端 以vue框架为例，登录流程大多数是router的钩子中实现，调用登录接口，对返回值做操作，然后`next()`，来把异步的登录插入到渲染流程中，但是小程序中，因为存在热启动的情况，所以需要把login接口调用写在`main.js`，但是又因为`main.js`里onshow的login接口 不能和`页面.js`里onshow的业务接口顺序调用，就导致业务接口可能带不了login返回的token。  
解决方法就是封装request的时候写一个异步的任务队列，当前token失效时，调用login，其他接口push到队列中等待，login接口返回后，顺序调用队列中的接口。 
## 优化 ##