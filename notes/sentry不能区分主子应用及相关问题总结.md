### 问题出现的原因在于：  
sentry通过覆写window.onerror和window.unhandledrejection的方式来捕获异常，之后不管哪个应用发生异常，都会触发他们的callback被sentry感知并上报到dsn配置的指定项目，而sentry的init不管放在微前端的哪个项目中，都会一股脑上报到某个项目中，无法区分。  
### 解决的切入点
当sentry捕获到异常时，会通过一个接口来上报异常，这个接口调用就是切入点：  
1. 观察接口的url，可以发现url可以通过配置的dsn转化而来，他们都包括项目id，sentry地址，sentry分配的项目key。  
2. 观察接口的参数，其中包括异常的调用栈信息，通过调用栈中的字段可以知道发生异常的js文件的url，因为微前端中各个应用的url前缀不同，所以可以用文件的url来判断异常属于哪个应用。
### 解决方案
1. 拦截上报接口，通过接口参数中的异常信息来判断属于哪个应用  
2. 根据应用对应的dsn构建上报url
3. 使用新的url上报异常

### 拦截上报接口方案
使用自定义的transport配置，自定义一个继承自默认的transport对象的对象，根据回掉函数中参数的url和options去做后续操作。  

以上步骤之后，可以区分主子应用

### 后续问题1: 不显示vue组件信息
sentry为了监听vue组件错误，在init过程中调用一个vueInit的方法修改app.config.errorHandler，但是因为上面解决方案中子应用并没有使用sentry，所以报错的位置没有正确显示，解决办法就是调用一下这个api。

### 后续问题2: sourcemap对应位置不正确
问题原因在于qiankun框架执行过程中会为子应用创建沙盒，无论沙盒是通过拷贝window快照，还是基于proxy去创建，无论脚本是同步加载还是异步加载的脚本，都会在执行时在脚本内容上添加 `with(global)` 来进行隔离。因为在脚本的第一行添加了新的代码，所以导致sourcemap不能正确对应。  
解决方法是使用webpack内置的bannerPlugin去在开头加一行注释，这样sourcemap会从第二行开始。

### 后续问题3: 子项目报错但显示主项目的代码信息
然后根据之前的步骤排查上报信息并没有发现额外的参数定义项目信息，所以猜测是由于异常的调用栈里包含不同来源的js文件导致，删除之后解决。

